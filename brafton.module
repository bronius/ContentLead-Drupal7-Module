<?php

/**
 * @file
 * These are the functions used to create the settings pages and import functions
 * fired by the drupal cron system. 
 */
//Set number of feeds to import
define("NUM_FEEDS", 1);
define("DEBUG", 1);
global $sourcefeed;

/**
 * Implement hook_node_info to add the 'news' node type
 */
function brafton_node_info() {
  return array(
    'b_news' => array(
      'name' => t('News Article'),
      'base' => 'node_content',
      'module' => 'brafton',
      'description' => t('A <em>news article</em> is a story about the 
                            latest industry news.'),
    )
  );
}

/**
 * Implementation of hook_perm() - adds permissions options to the admin menu.
 */
function brafton_perm() {
  return array('create news articles',
    'delete own news articles',
    'delete any news article',
    'edit own news article',
    'edit any news article');
}

/**
 * Implementation of hook_access() - allows Drupal to determine 
 * user access rights for standard node actions.
 */
function brafton_access($op, $node, $account) {

  if ($op == 'create') {
    return user_access('create b_news articles', $account);
  }
  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own b_news articles', $account) &&
        ($account->uid == $node->uid)) {
      return TRUE;
    } else {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Implementation of hook_view().
 */
function brafton_view($node, $teaser = FALSE, $page = FALSE) {
  if ($page) {
    // Breadcrumb navigation
    drupal_set_breadcrumb(array(l(t('Home'), NULL), l(t('News'), 'b_news')));
  }
  return node_prepare($node, $teaser);
}

/**
 * Implementation of hook_block().
 *
 * Adds a block to the Drupal instance which displays the most recent 
 * 10 news article titles with links to the articles. Intended for easy
 * 'headlines on homepage' implementation.
 */
function brafton_block($op = 'list', $delta = 0) {
  global $user;
  if ($op == 'list') {
    for ($i = 0; $i < NUM_FEEDS; $i++) {
      $block[$i]['info'] = t("Brafton feed #$i");
    }
    return $block;
  } else if ($op == 'view') {
    if (user_access('access content')) {
      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.created 
	    FROM {node} n LEFT JOIN {brafton} b ON n.nid = b.nid
		WHERE n.type = 'b_news' AND n.status = 1 AND  b.feed_id = $delta
		ORDER BY n.created DESC"), 0, 5);
      if ($node_title_list = node_title_list($result)) {
        $block['content'] = $node_title_list;
        $block['content'] .= theme('more_link', url('b_news'), t('Read breaking news.'));
        $block['subject'] = t('Recent news articles');
        return $block;
      }
    }
  }
}

/**
 * Implementation of hook_form().
 *
 * Defines the web form used to manually create/edit news nodes.
 */
/*
  function brafton_form(&$node, &$form_state) {
  global $nid;

  $iid = isset($_GET['iid']) ? (int)$_GET['iid'] : 0;
  //  $type = node_get_types('type', $node);
  node_types_rebuild();
  $type = node_type_get_types();

  if (empty($node->body)) {
  if ($nid && $news = node_load($nid)) {
  $node->body = '<em>'. $news->body .'</em> ['.
  l($news->name, "node/$nid") .']';
  }

  if ($iid &&
  $item = db_fetch_object(db_query('SELECT i.*, f.title as ftitle,
  f.link as flink
  FROM {aggregator_item} i,
  {aggregator_feed} f
  WHERE i.iid = %d AND i.fid = f.fid',
  $iid)))
  {
  $node->title = $item->title;
  // Note: $item->description has been validated on aggregation.
  $node->body = '<a href="'. check_url($item->link) .'">'.
  check_plain($item->title) .'</a> - <em>'.
  $item->description .'</em> [<a href="'.
  check_url($item->flink) .'">'. check_plain($item->ftitle)
  ."</a>]\n";
  }

  }

  $form['title'] = array('#type' => 'textfield',
  '#title' => check_plain($type->title_label),
  '#required' => TRUE,
  '#default_value' => !empty($node->title) ?
  $node->title : NULL, '#weight' => -5);
  //$form['body_field'] = node_body_field($node,
  //                                      $type->body_label,
  //                                      $type->min_word_count);
  $form['field_body'] = array('#type' => 'textarea',
  '#title' => check_plain($type->body_label),
  '#required' => $type->min_word_count > 0,
  '#default_value' => !empty($node->body) ?
  $node->body : NULL, '#rows' => 20);
  return $form;
  }
 */

/**
 * Add menu items
 */
function brafton_menu() {
  $menu = array();
  $menu['admin/settings/brafton'] = array(
    'title' => 'Brafton settings',
    'description' => "BraftonXML feed scheduled importer module settings",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('brafton_admin'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $menu;
}

/**
 * Create admin forms for configuring importer
 */
function brafton_admin() {
  $form = array();

  $form['brafton_feed'] = array(
    '#type' => 'select',
    '#title' => t('Feed Type'),
    '#default_value' => variable_get('brafton_feed'),
    '#options' => array(
      'api' => t('API Key'),
      'archive' => t('Archive'),
    ),
  );

  $form['brafton_apidomain'] = array(
    '#type' => 'select',
    '#title' => t('API Domain'),
    '#default_value' => variable_get('brafton_feed'),
    '#options' => array(
      'http://api.brafton.com/' => t('Brafton'),
      'http://api.contentlead.com/' => t('ContentLEAD'),
      'http://api.castleford.com/' => t('Castleford'),
    ),
  );


  $results = db_query("SELECT uid, name FROM {users}");
  foreach ($results as $users) {
    $array[$users->uid] = $users->name;
  }

  $form['brafton_author0'] = array(
    '#type' => 'select',
    '#title' => t('Feed #0 Author'),
    '#default_value' => variable_get('brafton_author0', 0),
    '#options' => $array,
  );

  //one form for each feed URL to be loaded
  for ($i = 0; $i < NUM_FEEDS; $i++) {
    $form["brafton_feedurl$i"] = array(
      '#type' => 'textfield',
      '#title' => t("Brafton XML feed URL: Feed #$i"),
      '#default_value' => variable_get("brafton_feedurl$i"),
      '#size' => 50,
      '#maxlength' => 255,
      '#description' => t("xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"),
      '#required' => TRUE,
    );
  }

  $form['brafton_archive'] = array(
    '#type' => 'textfield',
    '#title' => t("Brafton Archive File Location"),
    '#default_value' => variable_get('brafton_archive'),
    '#size' => 50,
    '#maxlength' => 255,
    '#description' => t("Path to Brafton Archive File"),
  );

  $form['brafton_postcreatedate'] = array(
    '#type' => 'select',
    '#title' => t('Submit Date'),
    '#default_value' => variable_get('brafton_postcreatedate'),
    '#options' => array(
      'created' => t('Published Date'),
      'altered' => t('Last Modified Date'),
    ),
  );

  return system_settings_form($form);
}

/**
 * Load the feed from the URL into memory and return an XPath object that 
 * can be used to navigate it.
 */
function _brafton_load_feed($feednum) {

  $doc = new DOMDocument();
  $feedType = variable_get("brafton_feed");

  if ($feedType == "api") {
    $apikey = variable_get("brafton_feedurl$feednum");
    $apidomain = variable_get("brafton_apidomain");
    $url = $apidomain . $apikey . "/news/";

    //load XML as string
    if ($url != "null") {
      $sourcefeed = file_get_contents($url);
    } else {
      return null;
    }
  } else {
    $sourcefeed = file_get_contents(variable_get("brafton_archive"));
  }

  //switch encoding to prevent bad character errors
  //$encodedfeed = iconv("ISO-8859-1", "UTF-8", $sourcefeed);
  $encodedfeed = $sourcefeed;

  //populate DOM, get XPath from DOM
  $doc->loadXML($encodedfeed);
  $xpath = new DOMXPath($doc);

  return $xpath;
}

function brafton_node_delete($node) {
  db_delete('brafton')
      ->condition('nid', $node->nid)
      ->execute();
  db_delete('brafton_pictures')
      ->condition('nid', $node->nid)
      ->execute();
}

function _brafton_load_newpath($link) {
  $doc = new DOMDocument();
  $url = $link;

  //load XML as string
  if ($url != "null") {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);

    $sourcefeed = curl_exec($ch);
    curl_setopt($ch, CURLOPT_URL, $url . "photos");
    $sourcefeed2 = curl_exec($ch);
    curl_setopt($ch, CURLOPT_URL, $url . "categories");
    $sourcefeed3 = curl_exec($ch);
  } else {
    return null;
  }

  //switch encoding to prevent bad character errors
  $feedarray = array();
  for ($i = 0; $i < 3; $i++) {
    switch ($i) {
      case 0:
        //$encodedfeed = iconv("ISO-8859-1", "UTF-8", $sourcefeed);
        $encodedfeed = $sourcefeed;
        break;
      case 1:
        //$encodedfeed = iconv("ISO-8859-1", "UTF-8", $sourcefeed2);
        $encodedfeed = $sourcefeed2;
        break;
      case 2:
        //$encodedfeed = iconv("ISO-8859-1", "UTF-8", $sourcefeed3);
        $encodedfeed = $sourcefeed3;
        break;
    }
    //populate DOM, get XPath from DOM
    $doc->loadXML($encodedfeed);
    $xpath = new DOMXPath($doc);
    $feedarray[] = $xpath;
  }
  return $feedarray;
}

/**
 * Implements hook_cron  -  invoked whenever the scheduler is called
 *
 * Top level function for the import process. In turn, it:
 *    - Loads the XML
 *    - Loops through list of articles
 *       - Preps data for storage in Drupal
 *       - Saves node info
 *       - Saves brafton-specific metadata
 *       - Saves node again to trigger clean URL creation
 *       - Saves picture info
 *       - Handles categories/vocabulary terms and applies them
 */
function brafton_cron() {
  if (DEBUG) {
    $fp = fopen('log.txt', 'w');
    fclose($fp);
  }

  //make sure Brafton News vocabulary exists, create it if it doesn't
  //_brafton_update_vocabulary();
  //Could potentially handle multiple feeds for one site.
  for ($feednum = 0; $feednum < NUM_FEEDS; $feednum++) {
    $xpath = _brafton_load_feed($feednum);
    if ($xpath == null)
      continue;  //bypass empty XML "gracefully"

      
// Select all Article nodes and loop through them 
    $articles = $xpath->evaluate("//newsListItem");
    for ($i = 0; $i < $articles->length; $i++) {
      $currentArticle = $articles->item($i);
      $id = $xpath->evaluate('id', $currentArticle)->item(0)->nodeValue;
      $publishDate = strtotime($xpath->evaluate('publishDate', $currentArticle)->item(0)->nodeValue);
      $lastModified = strtotime($xpath->evaluate('lastModifiedDate', $currentArticle)->item(0)->nodeValue);
      $postcreatedate = variable_get("brafton_postcreatedate");
      if ($postcreatedate == 'created') {
        $sortdate = $publishDate;
      } else {
        $sortdate = $lastModified;
      }
      //get url of article and create new xpath
      $link = $currentArticle->getAttribute('href');
      $xpathArray = _brafton_load_newpath($link);
      $xpathNews = $xpathArray[0];
      $iarticle = $xpathNews->evaluate("//newsItem");
      $ciarticle = $iarticle->item(0);

      //initialize the node object, either by loading an existing node
      //or by creating a new one if the article is fresh
      if ($updateId = _brafton_node_exists($id)) {

        $result = db_query("SELECT last_modified FROM {brafton} WHERE dn_id = :dnid", array(':dnid' => $id))->fetchAssoc();
        $changedDate = $result['last_modified'];

        if ($sortdate != $changedDate) {
          $node = node_load($updateId);
          $updatedArticle = true;
        } else {
          $updatedArticle = false;
        }
      } else {

        $updatedArticle = false;

        $node = array(
          'nid' => null,
          'type' => 'b_news',
          'date' => $publishDate,
          'log' => 'cron created',
          'format' => 2,
          'promote' => 0
        );
        $node = (object) $node;
      }


      if (!$updateId || $updatedArticle) {

        //load these values from the feed for all nodes, new and updated
        $node->title = $xpath->evaluate('headline', $currentArticle)->item(0)->nodeValue;
        $node->language = LANGUAGE_NONE;
        $node->teaser = $xpathNews->evaluate('extract', $ciarticle)->item(0)->nodeValue;
        $node->body[$node->language][0]['value'] = $xpathNews->evaluate('text', $ciarticle)->item(0)->nodeValue;
        $node->body[$node->language][0]['summary'] = $xpathNews->evaluate('extract', $ciarticle)->item(0)->nodeValue;
        $node->body[$node->language][0]['format'] = 'full_html';
        $node->type = 'b_news';
        //$node->field_tags[$node->language][]['tid'] = 1;

        if (!$updateId) {
          node_submit($node);
        }

        $node->created = $sortdate;
        $node->timestamp = $sortdate;

        $author = variable_get("brafton_author$feednum", 0);
        $node->uid = $author;

        node_save($node);


        //TABLE: {brafton}
        if ($updateId == NULL)
          $key = array();
        else
          $key = array('nid');
        $braftonData = array(
          'nid' => $node->nid,
          'feed_id' => $feednum,
          'dn_id' => $id,
          'headline' => $longheading = $xpath->evaluate('headline', $currentArticle)->item(0)->nodeValue,
          //'keyword' => $keyword = $xpathNews->evaluate('keyword', $ciarticle)->item(0)->nodeValue,
          //'source' => $source = $xpathNews->evaluate('source', $ciarticle)->item(0)->nodeValue,
          //'byline' => $byline = $xpathNews->evaluate('byline', $ciarticle)->item(0)->nodeValue,
          'last_modified' => $sortdate
        );
        drupal_write_record('brafton', $braftonData, $key);

        //save a second time to trigger URL generation, presumably with newly 
        //saved article ID
        $node->body[$node->language][0]['summary'] = $xpathNews->evaluate('extract', $ciarticle)->item(0)->nodeValue;
        $node->body[$node->language][0]['value'] = $xpathNews->evaluate('text', $ciarticle)->item(0)->nodeValue;
        node_save($node);

        //TABLE: {brafton_picture}
        if ($updateId == NULL)
          $pickey = array();
        else
          $pickey = array('nid');

        $xpathPic = $xpathArray[1];
        $pictree = $xpathPic->evaluate('//photo'); //NodeList Object
        $picNode = $pictree->item(0);
        if ($xpathPic->evaluate('//photo')->item(0) != NULL) {

          $image_url = $xpathPic->evaluate("photo/instances/instance/url")->item(0)->nodeValue;
          $image = file_get_contents($image_url);
          $file = file_save_data($image, file_default_scheme() . '://brafton_images/' . basename($image_url), FILE_EXISTS_REPLACE);
          $node->field_brafton_image['und'][0] = (array) $file;
          $node->field_brafton_image['und'][0]['alt'] = $xpathPic->evaluate('photo/caption')->item(0)->nodeValue;
          $node->field_brafton_image['und'][0]['title'] = $xpathPic->evaluate('photo/caption')->item(0)->nodeValue;

          node_save($node);

          $pictureData = array(
            'nid' => $node->nid,
            'caption' => $xpathPic->evaluate('photo/caption')->item(0)->nodeValue,
            'large_url' => $xpathPic->evaluate('photo/instances/instance/url')->item(0)->nodeValue,
            'lwidth' => $xpathPic->evaluate('photo/instances/instance/width')->item(0)->nodeValue,
            'lheight' => $xpathPic->evaluate('photo/instances/instance/height')->item(0)->nodeValue,
            'small_url' => $xpathPic->evaluate('photo/instances/instance/url')->item(1)->nodeValue,
            'swidth' => $xpathPic->evaluate('photo/instances/instance/width')->item(1)->nodeValue,
            'sheight' => $xpathPic->evaluate('photo/instances/instance/height')->item(1)->nodeValue,
          );
          drupal_write_record('brafton_pictures', $pictureData, $pickey);
        }

        //TABLE: {brafton_term} & {term_node}   
        //get 'categories' data
        $xpathCat = $xpathArray[2];
        $catID = $xpathCat->evaluate('//category/id'); //NodeList Object
        $catN = $xpathCat->evaluate('//category/name');

        $terms = array();
        $catarrayID = array();
        $catarrayName = array();
        foreach ($catID as $item) {
          $catarrayID[] = $item->nodeValue;
        }
        foreach ($catN as $item) {
          $catarrayName[] = $item->nodeValue;
        }
        $result = db_query('SELECT vid FROM {taxonomy_vocabulary} WHERE machine_name = :b_news_t', array(':b_news_t' => 'b_news_t'));
        $rows = $result->rowCount();
        if (!empty($rows)) {
          $record = $result->fetchAssoc();
          $vid = $record['vid'];
        } else {
          $result = db_query('SELECT * FROM {taxonomy_vocabulary} ORDER BY vid DESC LIMIT 1');
          $record = $result->fetchAssoc();
          $fields = array('vid' => $record['vid'] + 1, 'name' => 'b_news_t', 'machine_name' => 'b_news_t', 'hierarchy' => 0, 'module' => 'taxonomy');
          db_insert('taxonomy_vocabulary')->fields($fields)->execute();
          $vid = $record['vid'] + 1;
        }

        for ($j = 0; $j < count($catarrayID); $j++) {
          if (!term_exists($catarrayID[$j])) {
            $term = new stdClass();
            $term->vid = $vid;
            $term->name = $catarrayName[$j];
            taxonomy_term_save($term);
            $result = db_query('SELECT * FROM {taxonomy_term_data} ORDER BY tid DESC LIMIT 1');
            $record = $result->fetchAssoc();
            $tid = $record['tid'];
            $fields = array('tid' => $tid, 'dncid' => $catarrayID[$j]);
            db_insert('brafton_term')->fields($fields)->execute();
          }
          enter_tax_index($catarrayID[$j], $id);

          if (!$updateId) {
            $result = db_query('SELECT tid FROM {brafton_term} WHERE dncid = :id', array(':id' => $catarrayID[$j]));
            $result = $result->fetchAssoc();
            $tid = $result['tid'];

            $node->field_brafton_term[$node->language][] = array('tid' => $tid);
            node_save($node);
          }
        }
      }
    }
  }
  print "Articles loaded.";
}

function enter_tax_index($catid, $id) {
  $result = db_query('SELECT tid FROM {brafton_term} WHERE dncid = :id', array(':id' => $catid));
  $result = $result->fetchAssoc();
  $tid = $result['tid'];

  $result = db_query('SELECT nid FROM {brafton} WHERE dn_id = :id', array(':id' => $id));
  $nid_row = $result->fetchAssoc();
  $nid = $nid_row['nid'];
  $fields = array('nid' => $nid, 'tid' => $tid);
  db_insert('taxonomy_index')->fields($fields)->execute();
}

function term_exists($catid) {
  $result = db_query("SELECT tid FROM {brafton_term} WHERE  dncid = :dncid", array(':dncid' => $catid));
  $record = $result->fetchAssoc();
  if ($record['tid']) {
    $tid = $record['tid'];
  } else {
    $tid = null;
  }
  return $tid;
}

function newTag($tagName, $categoryID) {
  $result = db_query("SELECT name,tid FROM {taxonomy_term_data}");
  if (!$result) { // add this check.
    die('Invalid query: ' . mysql_error());
  }
  $c = 0;
  while ($row = mysql_fetch_array($result)) {
    if ($row['name'] == $tagName) {
      //$node->field_tags[$node->language][]['tid'] = $row['tid'];
      $c++;
    }
  }

  if ($c < 1) {
    $term = new stdClass();
    $term->name = (string) $tagName;
    $term->vid = 1; // �1� is a vocabulary id you wish this term to assign to
    taxonomy_term_save($term); // Finally, save our term
  }
}

/**
 * Check if article id exists within {brafton} table. If so, return 
 * the corresponding node id so the node can be loaded.
 */
function _brafton_node_exists($dnid) {

  $result = db_query("SELECT nid FROM {brafton} WHERE dn_id = '$dnid'", array(':dnid' => $dnid))->fetchAssoc();

  if ($result) {
    return $result['nid'];
  } else {
    return NULL;
  }
}

/**
 * Make sure News vocab is in place and save vid
 */
function _brafton_update_vocabulary() {
  $vid = variable_get('brafton_vocabulary', 0);
  $vocabularies = taxonomy_get_vocabularies();
  if (!isset($vocabularies[$vid])) {
    $vocabulary = array(
      'name' => t('b_news_t'),
      'description' => t(''),
      'multiple' => 1,
      'required' => 0,
      'hierarchy' => 0,
      'relations' => 1,
      'module' => 'taxonomy',
      'weight' => 0,
      'nodes' => array('b_news_t' => 1),
    );
    //taxonomy_vocabulary_save($vocabulary);
    //variable_set('brafton_vocabulary', $vocabulary['vid']);
  }
}

/**
 * Check if term is tagged with the category id
 */
function _brafton_term_exists($dncid) {
  if (DEBUG) {
    $fp = fopen("log.txt", 'a');
  }
  $res = db_query("SELECT tid FROM {brafton_term} WHERE dncid = '$dncid'");

  if (DEBUG)
    fwrite($fp, "looking for '$dncid'\n");
  $res_array = db_query("SELECT tid FROM {brafton_term} WHERE dncid = '$dncid'", array(':dncid' => $dncid))->fetchAssoc();
  ;
  if ($res_array) {
    if (DEBUG) {
      ob_start();
      var_dump($res_array);
      fwrite($fp, "\tmatched for array " . ob_get_contents() . "\n");
      fclose($fp);
      ob_end_clean();
    }
    return $res_array['tid'];
  } else {
    if (DEBUG) {
      fwrite($fp, "\tdncid not found\n");
      fclose($fp);
    }
    return null;
  }
}

?>
